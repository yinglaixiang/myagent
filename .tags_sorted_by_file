!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
AGENT_H_	include/agent.h	/^#define AGENT_H_$/;"	d
cJSON	include/cJSON.h	/^typedef struct cJSON {$/;"	s
cJSON	include/cJSON.h	/^} cJSON;$/;"	t	typeref:struct:cJSON
cJSON_AddBoolToObject	include/cJSON.h	/^#define cJSON_AddBoolToObject(/;"	d
cJSON_AddFalseToObject	include/cJSON.h	/^#define cJSON_AddFalseToObject(/;"	d
cJSON_AddNullToObject	include/cJSON.h	/^#define cJSON_AddNullToObject(/;"	d
cJSON_AddNumberToObject	include/cJSON.h	/^#define cJSON_AddNumberToObject(/;"	d
cJSON_AddStringToObject	include/cJSON.h	/^#define cJSON_AddStringToObject(/;"	d
cJSON_AddTrueToObject	include/cJSON.h	/^#define cJSON_AddTrueToObject(/;"	d
cJSON_Array	include/cJSON.h	/^#define cJSON_Array /;"	d
cJSON_False	include/cJSON.h	/^#define cJSON_False /;"	d
cJSON_Hooks	include/cJSON.h	/^typedef struct cJSON_Hooks {$/;"	s
cJSON_Hooks	include/cJSON.h	/^} cJSON_Hooks;$/;"	t	typeref:struct:cJSON_Hooks
cJSON_IsReference	include/cJSON.h	/^#define cJSON_IsReference /;"	d
cJSON_NULL	include/cJSON.h	/^#define cJSON_NULL /;"	d
cJSON_Number	include/cJSON.h	/^#define cJSON_Number /;"	d
cJSON_Object	include/cJSON.h	/^#define cJSON_Object /;"	d
cJSON_SetIntValue	include/cJSON.h	/^#define cJSON_SetIntValue(/;"	d
cJSON_SetNumberValue	include/cJSON.h	/^#define cJSON_SetNumberValue(/;"	d
cJSON_String	include/cJSON.h	/^#define cJSON_String /;"	d
cJSON_StringIsConst	include/cJSON.h	/^#define cJSON_StringIsConst /;"	d
cJSON_True	include/cJSON.h	/^#define cJSON_True /;"	d
cJSON__h	include/cJSON.h	/^#define cJSON__h$/;"	d
child	include/cJSON.h	/^    struct cJSON *child;        \/* An array or object item will have a child pointer pointing to a chain of the items in the array\/object. *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
free_fn	include/cJSON.h	/^      void (*free_fn)(void *ptr);$/;"	m	struct:cJSON_Hooks
malloc_fn	include/cJSON.h	/^      void *(*malloc_fn)(size_t sz);$/;"	m	struct:cJSON_Hooks
next	include/cJSON.h	/^    struct cJSON *next,*prev;   \/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::cJSON
prev	include/cJSON.h	/^    struct cJSON *next,*prev;   \/* next\/prev allow you to walk array\/object chains. Alternatively, use GetArraySize\/GetArrayItem\/GetObjectItem *\/$/;"	m	struct:cJSON	typeref:struct:cJSON::
string	include/cJSON.h	/^    char *string;               \/* The item's name string, if this item is the child of, or is in the list of subitems of an object. *\/$/;"	m	struct:cJSON
type	include/cJSON.h	/^    int type;                   \/* The type of the item, as above. *\/$/;"	m	struct:cJSON
valuedouble	include/cJSON.h	/^    double valuedouble;         \/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valueint	include/cJSON.h	/^    int valueint;               \/* The item's number, if type==cJSON_Number *\/$/;"	m	struct:cJSON
valuestring	include/cJSON.h	/^    char *valuestring;          \/* The item's string, if type==cJSON_String *\/$/;"	m	struct:cJSON
DEBUG_H_	include/debug.h	/^#define DEBUG_H_$/;"	d
TRACE_ERROR	include/debug.h	/^#define TRACE_ERROR(/;"	d
TRACE_PRINT	include/debug.h	/^#define TRACE_PRINT(/;"	d
DEBUG	include/rt_config.h	/^#define DEBUG	/;"	d
RT_CONFIG_H_	include/rt_config.h	/^#define RT_CONFIG_H_$/;"	d
_CHAR_IS_SIGNED	include/rt_config.h	/^#define _CHAR_IS_SIGNED	/;"	d
RT_IO_H_	include/rt_io.h	/^#define RT_IO_H_$/;"	d
io_error	include/rt_io.h	/^#define io_error /;"	d
io_print	include/rt_io.h	/^#define io_print /;"	d
__RT_OS_H__	include/rt_os.h	/^#define __RT_OS_H__$/;"	d
ALL_NUM	include/rt_seed.h	/^#define ALL_NUM /;"	d
BLOCK_DATA	include/rt_seed.h	/^#define   BLOCK_DATA /;"	d
BLOCK_HEAD	include/rt_seed.h	/^#define   BLOCK_HEAD /;"	d
CID_LENGTH	include/rt_seed.h	/^#define CID_LENGTH /;"	d
CONFIG_FILE_BUFFER_LENGTH	include/rt_seed.h	/^#define CONFIG_FILE_BUFFER_LENGTH /;"	d
CONFIG_FILE_FALLBACK_LEN	include/rt_seed.h	/^#define CONFIG_FILE_FALLBACK_LEN /;"	d
CONFIG_FILE_NAME	include/rt_seed.h	/^#define CONFIG_FILE_NAME	/;"	d
CONFIG_FILE_OFFSET_ICCID_LEN	include/rt_seed.h	/^#define CONFIG_FILE_OFFSET_ICCID_LEN /;"	d
CONFIG_FILE_OFFSET_PRIVIOUS_MCC_LEN	include/rt_seed.h	/^#define CONFIG_FILE_OFFSET_PRIVIOUS_MCC_LEN /;"	d
DATA_FLAG_LENGTH	include/rt_seed.h	/^#define DATA_FLAG_LENGTH /;"	d
FULL_PROFILE	include/rt_seed.h	/^#define FULL_PROFILE /;"	d
GET_MCC_CID_IMEI_FOR_AT	include/rt_seed.h	/^#define GET_MCC_CID_IMEI_FOR_AT$/;"	d
GROWTH_ROTE	include/rt_seed.h	/^#define GROWTH_ROTE /;"	d
HEAD_LENGTH	include/rt_seed.h	/^#define HEAD_LENGTH /;"	d
IMEI_LENGTH	include/rt_seed.h	/^#define IMEI_LENGTH /;"	d
INT_SAVE_IN_FILE_LEN	include/rt_seed.h	/^#define INT_SAVE_IN_FILE_LEN /;"	d
ITEM_FALLBACK	include/rt_seed.h	/^#define ITEM_FALLBACK /;"	d
ITEM_ICCID	include/rt_seed.h	/^#define ITEM_ICCID /;"	d
LENGTH_BUFFER_SIZE	include/rt_seed.h	/^#define LENGTH_BUFFER_SIZE /;"	d
MAX_BLOCK_SIZE	include/rt_seed.h	/^#define MAX_BLOCK_SIZE /;"	d
MSG_OFFSET_ICCID_LEN	include/rt_seed.h	/^#define MSG_OFFSET_ICCID_LEN /;"	d
PROFILE_IN_ASSETS	include/rt_seed.h	/^#define PROFILE_IN_ASSETS	/;"	d
PROFILE_STORAGE_FILE	include/rt_seed.h	/^#define PROFILE_STORAGE_FILE	/;"	d
REGISTER_DOC_INIT	include/rt_seed.h	/^#define REGISTER_DOC_INIT /;"	d
SORT_FALLBACK_BLOCK_SIZE	include/rt_seed.h	/^#define SORT_FALLBACK_BLOCK_SIZE /;"	d
SORT_FALLBACK_FILE_NAME	include/rt_seed.h	/^#define SORT_FALLBACK_FILE_NAME /;"	d
SORT_FALLBACK_NUM_HEAD_LEN	include/rt_seed.h	/^#define SORT_FALLBACK_NUM_HEAD_LEN /;"	d
__DEAL_SEED_H__	include/rt_seed.h	/^#define __DEAL_SEED_H__$/;"	d
__RT_TYPE_H_	include/rt_type.h	/^#define __RT_TYPE_H_$/;"	d
__int8_t_defined	include/rt_type.h	/^# define __int8_t_defined$/;"	d
__uint32_t_defined	include/rt_type.h	/^# define __uint32_t_defined$/;"	d
s16	include/rt_type.h	/^typedef short int       s16;$/;"	t
s32	include/rt_type.h	/^typedef int         	s32;$/;"	t
s64	include/rt_type.h	/^typedef long int        s64;$/;"	t
s64	include/rt_type.h	/^typedef long long int       s64;$/;"	t
s8	include/rt_type.h	/^typedef signed char     s8;$/;"	t
u16	include/rt_type.h	/^typedef unsigned short int u16;$/;"	t
u32	include/rt_type.h	/^typedef unsigned int        u32;$/;"	t
u64	include/rt_type.h	/^typedef unsigned long int   u64;$/;"	t
u64	include/rt_type.h	/^typedef unsigned long long int u64;$/;"	t
u8	include/rt_type.h	/^typedef unsigned char       u8;$/;"	t
COMPILER_ROOT	makefile	/^COMPILER_ROOT=\/opt\/ql-oe\/sysroots$/;"	m
CROSS_COMPILER	makefile	/^CROSS_COMPILER=$(COMPILER_ROOT)\/x86_64-linux\/usr\/bin\/arm-oe-linux-gnueabi\/arm-oe-linux-gnueabi-$/;"	m
GCC_VERSION	makefile	/^GCC_VERSION=4.9.2$/;"	m
INC_DIR	makefile	/^INC_DIR=-I .\/ \\$/;"	m
LOCAL_C_FLAGS	makefile	/^LOCAL_C_FLAGS = -march=armv7-a -mfloat-abi=soft -mfpu=vfp --sysroot=$(COMPILER_ROOT)\/mdm9607 \\$/;"	m
LOCAL_SRC_FILES	makefile	/^LOCAL_SRC_FILES = example\/MyAgent\/src\/agent.cpp \\$/;"	m
OEM_LIB_PATH	makefile	/^OEM_LIB_PATH=$(COMPILER_ROOT)\/mdm9607\/usr\/lib$/;"	m
STD_LIB	makefile	/^STD_LIB=\\$/;"	m
STD_LIB_PATH	makefile	/^STD_LIB_PATH=$(COMPILER_ROOT)\/x86_64-linux\/usr\/lib$/;"	m
USR_LIB	makefile	/^USR_LIB=$/;"	m
USR_LIB_PATH	makefile	/^USR_LIB_PATH=.\/libs$/;"	m
main	src/agent.cpp	/^int main()$/;"	f
buffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:
cJSON_AddItemReferenceToArray	src/cJSON.c	/^void    cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)                        {cJSON_AddItemToArray(array,create_reference(item));}$/;"	f
cJSON_AddItemReferenceToObject	src/cJSON.c	/^void    cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)    {cJSON_AddItemToObject(object,string,create_reference(item));}$/;"	f
cJSON_AddItemToArray	src/cJSON.c	/^void   cJSON_AddItemToArray(cJSON *array, cJSON *item)                      {cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}$/;"	f
cJSON_AddItemToObject	src/cJSON.c	/^void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)  {if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_AddItemToObjectCS	src/cJSON.c	/^void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)    {if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}$/;"	f
cJSON_CreateArray	src/cJSON.c	/^cJSON *cJSON_CreateArray(void)                  {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}$/;"	f
cJSON_CreateBool	src/cJSON.c	/^cJSON *cJSON_CreateBool(int b)                  {cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}$/;"	f
cJSON_CreateDoubleArray	src/cJSON.c	/^cJSON *cJSON_CreateDoubleArray(const double *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateFalse	src/cJSON.c	/^cJSON *cJSON_CreateFalse(void)                  {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}$/;"	f
cJSON_CreateFloatArray	src/cJSON.c	/^cJSON *cJSON_CreateFloatArray(const float *numbers,int count)   {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateIntArray	src/cJSON.c	/^cJSON *cJSON_CreateIntArray(const int *numbers,int count)       {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateNull	src/cJSON.c	/^cJSON *cJSON_CreateNull(void)                   {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}$/;"	f
cJSON_CreateNumber	src/cJSON.c	/^cJSON *cJSON_CreateNumber(double num)           {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}$/;"	f
cJSON_CreateObject	src/cJSON.c	/^cJSON *cJSON_CreateObject(void)                 {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}$/;"	f
cJSON_CreateString	src/cJSON.c	/^cJSON *cJSON_CreateString(const char *string)   {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}$/;"	f
cJSON_CreateStringArray	src/cJSON.c	/^cJSON *cJSON_CreateStringArray(const char **strings,int count)  {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}$/;"	f
cJSON_CreateTrue	src/cJSON.c	/^cJSON *cJSON_CreateTrue(void)                   {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}$/;"	f
cJSON_Delete	src/cJSON.c	/^void cJSON_Delete(cJSON *c)$/;"	f
cJSON_DeleteItemFromArray	src/cJSON.c	/^void   cJSON_DeleteItemFromArray(cJSON *array,int which)            {cJSON_Delete(cJSON_DetachItemFromArray(array,which));}$/;"	f
cJSON_DeleteItemFromObject	src/cJSON.c	/^void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}$/;"	f
cJSON_DetachItemFromArray	src/cJSON.c	/^cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)            {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;$/;"	f
cJSON_DetachItemFromObject	src/cJSON.c	/^cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}$/;"	f
cJSON_Duplicate	src/cJSON.c	/^cJSON *cJSON_Duplicate(cJSON *item,int recurse)$/;"	f
cJSON_GetArrayItem	src/cJSON.c	/^cJSON *cJSON_GetArrayItem(cJSON *array,int item)                {cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}$/;"	f
cJSON_GetArraySize	src/cJSON.c	/^int    cJSON_GetArraySize(cJSON *array)                         {cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}$/;"	f
cJSON_GetErrorPtr	src/cJSON.c	/^const char *cJSON_GetErrorPtr(void) {return ep;}$/;"	f
cJSON_GetObjectItem	src/cJSON.c	/^cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)    {cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}$/;"	f
cJSON_InitHooks	src/cJSON.c	/^void cJSON_InitHooks(cJSON_Hooks* hooks)$/;"	f
cJSON_InsertItemInArray	src/cJSON.c	/^void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)       {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}$/;"	f
cJSON_Minify	src/cJSON.c	/^void cJSON_Minify(char *json)$/;"	f
cJSON_New_Item	src/cJSON.c	/^static cJSON *cJSON_New_Item(void)$/;"	f	file:
cJSON_Parse	src/cJSON.c	/^cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}$/;"	f
cJSON_ParseWithOpts	src/cJSON.c	/^cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)$/;"	f
cJSON_Print	src/cJSON.c	/^char *cJSON_Print(cJSON *item)              {return print_value(item,0,1,0);}$/;"	f
cJSON_PrintBuffered	src/cJSON.c	/^char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)$/;"	f
cJSON_PrintUnformatted	src/cJSON.c	/^char *cJSON_PrintUnformatted(cJSON *item)   {return print_value(item,0,0,0);}$/;"	f
cJSON_ReplaceItemInArray	src/cJSON.c	/^void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)      {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;$/;"	f
cJSON_ReplaceItemInObject	src/cJSON.c	/^void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}$/;"	f
cJSON_free	src/cJSON.c	/^static void (*cJSON_free)(void *ptr) = free;$/;"	v	file:
cJSON_malloc	src/cJSON.c	/^static void *(*cJSON_malloc)(size_t sz) = malloc;$/;"	v	file:
cJSON_strcasecmp	src/cJSON.c	/^static int cJSON_strcasecmp(const char *s1,const char *s2)$/;"	f	file:
cJSON_strdup	src/cJSON.c	/^static char* cJSON_strdup(const char* str)$/;"	f	file:
create_reference	src/cJSON.c	/^static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}$/;"	f	file:
ensure	src/cJSON.c	/^static char* ensure(printbuffer *p,int needed)$/;"	f	file:
ep	src/cJSON.c	/^static const char *ep;$/;"	v	file:
firstByteMark	src/cJSON.c	/^static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };$/;"	v	file:
length	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:
offset	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	m	struct:__anon1	file:
parse_array	src/cJSON.c	/^static const char *parse_array(cJSON *item,const char *value)$/;"	f	file:
parse_hex4	src/cJSON.c	/^static unsigned parse_hex4(const char *str)$/;"	f	file:
parse_number	src/cJSON.c	/^static const char *parse_number(cJSON *item,const char *num)$/;"	f	file:
parse_object	src/cJSON.c	/^static const char *parse_object(cJSON *item,const char *value)$/;"	f	file:
parse_string	src/cJSON.c	/^static const char *parse_string(cJSON *item,const char *str)$/;"	f	file:
parse_value	src/cJSON.c	/^static const char *parse_value(cJSON *item,const char *value)$/;"	f	file:
pow2gt	src/cJSON.c	/^static int pow2gt (int x)   {   --x;    x|=x>>1;    x|=x>>2;    x|=x>>4;    x|=x>>8;    x|=x>>16;   return x+1; }$/;"	f	file:
print_array	src/cJSON.c	/^static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
print_number	src/cJSON.c	/^static char *print_number(cJSON *item,printbuffer *p)$/;"	f	file:
print_object	src/cJSON.c	/^static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
print_string	src/cJSON.c	/^static char *print_string(cJSON *item,printbuffer *p)$/;"	f	file:
print_string_ptr	src/cJSON.c	/^static char *print_string_ptr(const char *str,printbuffer *p)$/;"	f	file:
print_value	src/cJSON.c	/^static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)$/;"	f	file:
printbuffer	src/cJSON.c	/^typedef struct {char *buffer; int length; int offset; } printbuffer;$/;"	t	typeref:struct:__anon1	file:
skip	src/cJSON.c	/^static const char *skip(const char *in)$/;"	f	file:
suffix_object	src/cJSON.c	/^static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}$/;"	f	file:
update	src/cJSON.c	/^static int update(printbuffer *p)$/;"	f	file:
rt_io_create	src/rt_io.cpp	/^bool rt_io_create(const s8 *filename)$/;"	f
rt_io_read	src/rt_io.cpp	/^bool rt_io_read(const s8 *filename,us16 offset,s8 *buffer,u32 size)$/;"	f
rt_io_write	src/rt_io.cpp	/^bool rt_io_write(const s8 *filename,us16 offset,s8 *buffer,u32 size)$/;"	f
rt_creat_msg_queue	src/rt_os.cpp	/^s32 rt_creat_msg_queue(void)$/;"	f
rt_create_task	src/rt_os.cpp	/^bool rt_create_task(rt_task *task_id,rt_taskfun task_fun)$/;"	f
rt_mutex_destroy	src/rt_os.cpp	/^bool rt_mutex_destroy(pthread_mutex_t *mutex)$/;"	f
rt_mutex_init	src/rt_os.cpp	/^bool rt_mutex_init(pthread_mutex_t *mutex)$/;"	f
rt_mutex_lock	src/rt_os.cpp	/^s32 rt_mutex_lock(pthread_mutex_t *mutex)$/;"	f
rt_mutex_unlock	src/rt_os.cpp	/^bool rt_mutex_unlock(pthread_mutex_t *mutex)$/;"	f
rt_os_access	src/rt_os.cpp	/^s32 rt_os_access(const s8 *filenpath, s32 mode)$/;"	f
rt_os_error	src/rt_os.cpp	/^#define rt_os_error /;"	d	file:
rt_os_error	src/rt_os.cpp	/^#define rt_os_error(/;"	d	file:
rt_os_free	src/rt_os.cpp	/^void rt_os_free(void *mem)$/;"	f
rt_os_malloc	src/rt_os.cpp	/^void *rt_os_malloc(u32 size)$/;"	f
rt_os_memcmp	src/rt_os.cpp	/^void *rt_os_memcmp(void *mem_des,void *mem_src,s32 len)$/;"	f
rt_os_memcpy	src/rt_os.cpp	/^void *rt_os_memcpy(void *mem_des,void *mem_src,s32 len)$/;"	f
rt_os_memset	src/rt_os.cpp	/^void *rt_os_memset(void *mem,s8 value,s32 len)$/;"	f
rt_os_printf	src/rt_os.cpp	/^#define rt_os_printf /;"	d	file:
rt_os_printf	src/rt_os.cpp	/^#define rt_os_printf(/;"	d	file:
rt_os_strchr	src/rt_os.cpp	/^s8 *rt_os_strchr(s8 *str, const s8 chr)$/;"	f
rt_os_strcmp	src/rt_os.cpp	/^s32 rt_os_strcmp(void *mem_des,void *mem_src)$/;"	f
rt_os_strcpy	src/rt_os.cpp	/^s8 *rt_os_strcpy(char* dest, const char *src)$/;"	f
rt_os_strlen	src/rt_os.cpp	/^size_t rt_os_strlen(void *string)$/;"	f
rt_os_strncmp	src/rt_os.cpp	/^s32 rt_os_strncmp(void *mem_des,void *mem_src,s32 len)$/;"	f
rt_os_strstr	src/rt_os.cpp	/^s8 *rt_os_strstr(s8 *str1, const s8 *str2)$/;"	f
rt_receive_queue_msg	src/rt_os.cpp	/^bool rt_receive_queue_msg(s32 msgid,void *buffer,s32 len)$/;"	f
rt_send_queue_msg	src/rt_os.cpp	/^bool rt_send_queue_msg(s32 msgid,void *buffer,s32 len)$/;"	f
init_seed	src/rt_seed.cpp	/^bool init_seed(void)$/;"	f
seed_access	src/rt_seed.cpp	/^int32_t seed_access(int8_t *filename)$/;"	f
seed_create_fallback	src/rt_seed.cpp	/^bool seed_create_fallback(int8_t *buf)$/;"	f
seed_create_rt_config	src/rt_seed.cpp	/^bool seed_create_rt_config(void)$/;"	f
seed_create_sort_fallback	src/rt_seed.cpp	/^bool seed_create_sort_fallback(int8_t *buf)$/;"	f
seed_error	src/rt_seed.cpp	/^#define seed_error /;"	d	file:
seed_error	src/rt_seed.cpp	/^#define seed_error(/;"	d	file:
seed_exist	src/rt_seed.cpp	/^void seed_exist(void)$/;"	f
seed_printf	src/rt_seed.cpp	/^#define seed_printf /;"	d	file:
seed_printf	src/rt_seed.cpp	/^#define seed_printf(/;"	d	file:
